;; functions for working with annotated gcode generated by slic3r

(require 'peg)

(defvar slic3r-gcode/layer-regexp ".*move to next layer (\\([0-9]+\\))")

(defvar-local slic3r-gcode/line-info nil)

(defun slic3r-gcode/parse-line ()
  (nreverse (peg-parse
             (line (opt gcode (list (* ws arg)))
                   (opt ws) (or comment `( -- nil)) "\n"
                   `(gcode args comment -- :gcode gcode :args args :comment comment))
             (gcode (substring (or "M" "G") integer))
             (integer (+ [0-9]))
             (arg (substring [A-Z]) (substring number)
                  `(char number -- (cons (intern char)
                                         (string-to-number number))))
             (number (opt sign) integer (opt "." integer))
             (sign ["+-"])
             (ws (+ [" \t"]))
             (comment ";" (opt ws) (substring (+ (not "\n") (any)))))))

(defun slic3r-gcode/current-layer ()
  (save-excursion
    (when (re-search-backward slic3r-gcode/layer-regexp (line-beginning-position -2000) t)
      (string-to-number (match-string 1)))))

(defun slic3r-gcode/current-feedrate()
  (save-excursion
    (when (re-search-backward "G1 F\\([0-9]+\\)" (line-beginning-position -2000) t)
      (string-to-number (match-string 1)))))

(defun slic3r-gcode/previous-layer ()
  "Move point to beginning of previous layer."
  (interactive)
  (when (re-search-backward slic3r-gcode/layer-regexp nil t)
    (beginning-of-line)
    (string-to-number (match-string 1))))

(defun slic3r-gcode/next-layer ()
  "Move point to beginning of next layer"
  (interactive)
  (when (re-search-forward slic3r-gcode/layer-regexp nil t)
    (beginning-of-line 2)
    (string-to-number (match-string 1))))

;; (defun slic3r-gcode/looking-at-move (type)
;;   "Call 'looking-at' with commented line typically produced by slic3r output"
;;   (looking-at (format ".*; %s$" type)))

(defun slic3r-gcode/analyze ()
  "Analyze buffer, set buffer info to a property list for each line which describes moves and states"
  (save-excursion
    (goto-char (point-min))
    (unless slic3r-gcode/line-info (setq slic3r-gcode/line-info (make-hash-table)))
    (loop with preamble-t = t
          until (eobp)
          for line = (slic3r-gcode/parse-line)
          for gcode = (plist-get line :gcode)
          for args = (plist-get line :args)
          for comment = (plist-get line :comment)
          for layer = (if comment
                          (if (string-match slic3r-gcode/layer-regexp comment)
                              (string-to-number (match-string 1 comment))
                            layer)
                        layer)
          for line-number from 0
          for extrusion = (find 'E args :key 'car)
          for move = (string-equal gcode "G1")
          for move-type = (cond ((string-equal comment "perimeter")
                                 'perimeter)
                                ((string-equal comment "infill")
                                 'infill)
                                ((string-equal comment "skirt")
                                 'skirt))
          with plane-distance
          with current-feedrate
          for last-x = 0 then (or x last-x)
          for last-y = 0 then (or y last-y)
          for last-z = 0 then (or z last-z)
          for x = (alist-get 'X args)
          for y = (alist-get 'Y args)
          for z = (alist-get 'Z args)
          for f = (alist-get 'F args)
          for current-feedrate = (if f f current-feedrate)
          for plane-distance = (when (and move (or x y))
                                 (let ((dx (- x last-x))
                                       (dy (- y last-y)))
                                   (sqrt (+ (* dx dx) (* dy dy)))))
          for plane-speed = (when plane-distance
                              (/ current-feedrate 60))
          for line-info = (when move
                            (list* :line line-number :type move-type :feedrate current-feedrate :plane-distance plane-distance
                                   :plane-speed plane-speed :z z :layer layer
                                   line))
          when line-info
          do (setf (gethash line-number slic3r-gcode/line-info) line-info)
          finally (return nil))))

(define-derived-mode slic3r-gcode-mode nil "Slic3r-Gcode"
  (setq header-line-format
        '(:eval (format "Current Layer: %s %s"
                        (or (slic3r-gcode/current-layer) "Preamble/not found")
                        (let ((fr (slic3r-gcode/current-feedrate)))
                          (if fr (format "F%s" fr) "")))))
  (define-key slic3r-gcode-mode-map (kbd "C-j") 'slic3r-gcode/next-layer)
  (define-key slic3r-gcode-mode-map (kbd "C-k") 'slic3r-gcode/previous-layer))
