;; functions for working with annotated gcode generated by slic3r

(defvar slic3r-gcode/layer-regexp ".*move to next layer (\\([0-9]+\\))$")

(defun slic3r-gcode/current-layer ()
  (save-excursion
    (when (re-search-backward slic3r-gcode/layer-regexp nil t)
      (string-to-number (match-string 1)))))

(defun slic3r-gcode/current-feedrate()
  (save-excursion
    (when (re-search-backward "G1 F\\([0-9]+\\)" nil t)
      (string-to-number (match-string 1)))))

(defun slic3r-gcode/previous-layer ()
  "Move point to beginning of previous layer."
  (interactive)
  (when (re-search-backward slic3r-gcode/layer-regexp nil t)
    (beginning-of-line)
    (string-to-number (match-string 1))))

(defun slic3r-gcode/next-layer ()
  "Move point to beginning of next layer"
  (interactive)
  (when (re-search-forward slic3r-gcode/layer-regexp nil t)
    (beginning-of-line 2)
    (string-to-number (match-string 1))))

(defun slic3r-gcode/looking-at-move (type)
  "Call 'looking-at' with commented line typically produced by slic3r output"
  (looking-at (format ".*; %s$" type)))

(defun slic3r-gcode/analyze ()
  "Analyze buffer (WIP)"
  (save-excursion
    (goto-char (point-min))
    (loop with preamble-t = t
          with move-type
          for line from 1
          do (cond))))

(define-derived-mode slic3r-gcode-mode nil "Slic3r-Gcode"
  (setq header-line-format
        '(:eval (format "Current Layer: %s %s"
                        (or (slic3r-gcode/current-layer) "Preamble")
                        (let ((fr (slic3r-gcode/current-feedrate)))
                          (if fr (format "F%s" fr) "")))))
  (define-key slic3r-gcode-mode-map (kbd "C-j") 'slic3r-gcode/next-layer)
  (define-key slic3r-gcode-mode-map (kbd "C-k") 'slic3r-gcode/previous-layer))
